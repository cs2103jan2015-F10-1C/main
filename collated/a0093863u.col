//@author: a0093863u



	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Date.cpp
	 */

string Date::standardizeMonth(string month){
	stringstream ss;
	string monthKey[36] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
		"jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec",
		"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12" };
	int pos = -1;
	for (size_t i = 0; i < 36; i++) {
		if (month == monthKey[i]) {
			int value = (i+1)%12;
			if (value == 0){
				value = 12;
			}
			ss << value;
			return ss.str();
		}
	}
	
	return month;
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Date.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Date.cpp
	 */

bool Date::seperateDateNMonth(string& date, string& month, string all){

	string monthKey[24] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
		"jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec" };

	int pos1 = -1, pos2 = -1;
	pos1 = all.find("/");
	pos2 = all.find_first_of(' ');

	if (pos1 > 0 && pos2 < 0){
		date = all.substr(0, pos1);
		month = all.substr(pos1 + 1);
		return true;
	}
	else if (pos1 < 0 && pos2 > 0){
		string part1 = all.substr(0, pos2);
		string part2 = all.substr(pos2 + 1);
		for (size_t i = 0; i < 24; i++) {
			if (monthKey[i] == part1){
				month = part1;
				date = part2;
				return true;
			}
			else if (monthKey[i] == part2){
				month = part2;
				date = part1;
				return true;
			}
		}
	}
	else{
		return false;
	}
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Date.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Date.cpp
	 */

bool Date::verifyValidDate(string dateNMonth, bool& isConventionalDate){
	string date = "", month = "";

	isConventionalDate = seperateDateNMonth(date, month, dateNMonth); // Conventional date is eg. 3/3, mar 3, 3 mar. 
																		   //Next monday is not a conventional date.
	if (isConventionalDate){
		month = standardizeMonth(month);

		int intDate = atoi(date.c_str());
		int intMonth = atoi(month.c_str());
		if (intMonth < 1 || (intMonth > MONTH_PER_YEAR && intMonth!=99)){
			return false;
		}
		switch (intMonth){
		case 99:
			if (intDate == 99){
				return true;
			}
			else{
				return false;
			}
		case 1:
		case 3:
		case 5:
		case 7:
		case 8:
		case 10:
		case 12:
			if (intDate >= 1 && intDate <= DAY_PER_SOLAR_MONTH_OF_31){
				return true;
			}
			else{
				return false;
			}
		case 4:
		case 6:
		case 9:
		case 11:
			if (intDate >= 1 && intDate <= DAY_PER_SOLAR_MONTH_OF_30){
				return true;
			}
			else{
				return false;
			}
		case 2:
			struct tm * timeInfo = new struct tm;
			int year = timeInfo->tm_year + 1900;
			if (year % 100 != 0 && year % 4 == 0){
				if (intDate >= 1 && intDate <= DAY_OF_FEB_IN_LEAP_YEAR){
					return true;
				}
				else{
					return false;
				}
			}
			else if (year % 100 == 0 && year % 400 == 0){
				if (intDate >= 1 && intDate <= DAY_OF_FEB_IN_LEAP_YEAR){
					return true;
				}
				else{
					return false;
				}
			}
			else{
				if (intDate >= 1 && intDate <= DAY_OF_FEB_IN_NON_LEAP_YEAR){
					return true;
				}
				else{
					return false;
				}
			}
		}
	}
	return true;
}

	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Date.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteDisplay.cpp
	 */

void ExecuteDisplay::pushToAllItem(vector<list<StickyNote>::iterator>& day, vector<list<StickyNote>::iterator>& _allItems) {

	vector<list<StickyNote>::iterator>::iterator iter;

	iter = day.begin();
	int size = day.size();
	vector<vector<list<StickyNote>::iterator>::iterator> toDelete;

	for (size_t i = 0; i < size; i++, iter++) {
		if (day[i]->getPriority() == "high" && day[i]->getStatus() != "cleared") {
			_allItems.push_back(day[i]);
			toDelete.push_back(iter);
		}
	}
	while (!toDelete.empty()) {
		day.erase(toDelete.back());
		toDelete.pop_back();
	}

	for (size_t i = 0; i < day.size(); i++) {
		if (day[i]->getStatus() != "cleared") {
			_allItems.push_back(day[i]);
		}
	}

	day.clear();

}

	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteDisplay.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteDisplay.cpp
	 */

void ExecuteDisplay::getDay7Tasks(vector<list<StickyNote>::iterator>& day7, Storage& _storage) {
	Date date;
	string xDay = date.getXDaysLaterDate(6);
	list<StickyNote>::iterator iter = _storage.getIter();
	size_t _size = _storage.getSize();

	for (size_t i = 0; i < _size; i++, iter++){
		if (iter->getDate() == xDay){
			day7.push_back(iter);
		}
	}

}

	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteDisplay.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteMark.cpp
	 */

string ExecuteMark::execute(Storage& _storage, ExtDataBase _extdb, vector<list<StickyNote>::iterator>& _allItems, bool& successful) {

	string index = _task->getRemaining();
	bool isFound = false;
	bool isUndo = false;
	string type = index.substr(0, 4);
	if (type == "undo") {
		isUndo = true;
		index = index.substr(5);
	}

	for (size_t i = 0; i < index.size(); i++) {
		if (index[i] < '0' || index[i] > '9') {
			successful = false;
			return MESSAGE_WRONG_INDEX;
		}
	}

	list<StickyNote>::iterator iter;

	if (index.size() == 6) {

		iter = _storage.getIter();
		for (size_t i = 0; i < _storage.getSize(); i++, iter++) {
			if (iter->getIndex() == index) {
				isFound = true;
				break;
			}
		}
	}
	else {
		int forEdit = atoi(index.c_str());
		forEdit--;

		if (forEdit < 0 || forEdit >= _allItems.size()) {
			successful = false;
			return MESSAGE_WRONG_INDEX;
		}

		isFound = true;
		iter = _allItems[forEdit];
	}

	if (isUndo) {
		iter->setStatus("incomplete");
		_storage.findClashes();
		successful = true;
		return MESSAGE_MARKED;

	}

	if (isFound && !isUndo) {
		string undo = "mark undo " + iter->getIndex();
		_undoMark.push(undo);
		iter->setStatus("cleared");
		_storage.findClashes();
		successful = true;
		return MESSAGE_MARKED;
	}
	else {
		successful = false;
		return MESSAGE_WRONG_INDEX;
	}
}

string ExecuteMark::undo() {

	string undoMark;
	undoMark = _undoMark.top();
	_undoMark.pop();
	return undoMark;
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteMark.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteSearch.cpp
	 */

bool ExecuteSearch::haveThisInfo(string infoToBeSearched, list<StickyNote>::iterator iter) {

	string details, date, time, priority;
	if (iter->getDetails() == ""){
		details = "";
	}
	else{
		details = iter->getDetails();
	}

	if (iter->getDate() == "unbounded event"){
		date = "";
	}
	else{
		date = iter->getDate();
	}

	if (iter->getTime() == "All day event"){
		time = "";
	}
	else{
		time = iter->getTime();
	}

	if (iter->getPriority() == ""){
		priority = "";
	}
	else{
		priority = iter->getPriority();
	}
	
	return (compareStrings(infoToBeSearched, details) || compareStrings(infoToBeSearched, date) ||
		compareStrings(infoToBeSearched, time) || compareStrings(infoToBeSearched, priority));
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteSearch.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteSearch.cpp
	 */

bool ExecuteSearch::compareStrings(string infoToBeSearched, string infoToBeChecked) {

	if (infoToBeSearched.length()>infoToBeChecked.length()){
		return false;
	}
	else{
		size_t startingPosOfTask, startingPosOfInfo, posUnderChecking;
		for (startingPosOfTask = 0; startingPosOfTask<infoToBeChecked.length(); startingPosOfTask++){
			startingPosOfInfo = 0;
			posUnderChecking = startingPosOfTask;
			while (posUnderChecking<infoToBeChecked.length() &&
				infoToBeChecked[posUnderChecking] == infoToBeSearched[startingPosOfInfo]){
				posUnderChecking++;
				startingPosOfInfo++;
			}

			if (startingPosOfInfo == infoToBeSearched.length()){
				return true;
			}
		}
		return false;
	}
}

string ExecuteSearch::undo() {
	return "";
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteSearch.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteSort.cpp
	 */

string ExecuteSort::sortTasksByDate(Storage& _storage){

	vector<list<StickyNote>::iterator> futureTasks;
	getFutureTasks(futureTasks, _storage);

	ostringstream oss;

	vector<list<StickyNote>::iterator> jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec;
	for (size_t i = 0; i < futureTasks.size(); i++){
		switch (futureTasks[i]->getMonth()){
		case 1:
			jan.push_back(futureTasks[i]);
			break;
		case 2:
			feb.push_back(futureTasks[i]);
			break;
		case 3:
			mar.push_back(futureTasks[i]);
			break;
		case 4:
			apr.push_back(futureTasks[i]);
			break;
		case 5:
			may.push_back(futureTasks[i]);
			break;
		case 6:
			jun.push_back(futureTasks[i]);
			break;
		case 7:
			jul.push_back(futureTasks[i]);
			break;
		case 8:
			aug.push_back(futureTasks[i]);
			break;
		case 9:
			sep.push_back(futureTasks[i]);
			break;
		case 10:
			oct.push_back(futureTasks[i]);
			break;
		case 11:
			nov.push_back(futureTasks[i]);
			break;
		case 12:
			dec.push_back(futureTasks[i]);
			break;
		default:
			break;
		}
	}


	vector<list<StickyNote>::iterator> sortedFutureTasks;
	if (jan.size() > 0){
		std::sort(jan.begin(), jan.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < jan.size(); i++){
			sortedFutureTasks.push_back(jan[i]);
		}
	}
	if (feb.size() > 0){
		std::sort(feb.begin(), feb.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < feb.size(); i++){
			sortedFutureTasks.push_back(feb[i]);
		}
	}
	if (mar.size() > 0){
		std::sort(mar.begin(), mar.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < mar.size(); i++){
			sortedFutureTasks.push_back(mar[i]);
		}
	}
	if (apr.size() > 0){
		std::sort(apr.begin(), apr.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < apr.size(); i++){
			sortedFutureTasks.push_back(apr[i]);
		}
	}
	if (may.size() > 0){
		std::sort(may.begin(), may.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < may.size(); i++){
			sortedFutureTasks.push_back(may[i]);
		}
	}
	if (jun.size() > 0){
		std::sort(jun.begin(), jun.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < jun.size(); i++){
			sortedFutureTasks.push_back(jun[i]);
		}
	}
	if (jul.size() > 0){
		std::sort(jul.begin(), jul.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < jul.size(); i++){
			sortedFutureTasks.push_back(jul[i]);
		}
	}
	if (aug.size() > 0){
		std::sort(aug.begin(), aug.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < aug.size(); i++){
			sortedFutureTasks.push_back(aug[i]);
		}
	}
	if (sep.size() > 0){
		std::sort(sep.begin(), sep.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < sep.size(); i++){
			sortedFutureTasks.push_back(sep[i]);
		}
	}
	if (oct.size() > 0){
		std::sort(oct.begin(), oct.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < oct.size(); i++){
			sortedFutureTasks.push_back(oct[i]);
		}
	}
	if (nov.size() > 0){
		std::sort(nov.begin(), nov.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < nov.size(); i++){
			sortedFutureTasks.push_back(nov[i]);
		}
	}
	if (dec.size() > 0){
		std::sort(dec.begin(), dec.end(), compareTwoTasksByDay());
		for (size_t i = 0; i < dec.size(); i++){
			sortedFutureTasks.push_back(dec[i]);
		}
	}

	for (size_t j = 0; j < sortedFutureTasks.size(); j++){
		oss << j + 1 << "." << getAllInfoOfOneTask(sortedFutureTasks[j]) << "\r\n";
	}

	return oss.str();
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExecuteSort.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExtDataBase.cpp
	 */

void ExtDataBase::archive(string done) {

	ofstream ofs;
	ofs.open("../archive.txt", ios::app);
	if (ofs.is_open()) {
		ofs << done << endl;
	}
	ofs.close();
	return;
}

	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\ExtDataBase.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\HandleInput.cpp
	 */

string HandleInput::getIndex(string date, Storage _storage) {

	string defaultIndex = "0000";
	string returnIndex = "";
	int numberOfTask = 0;
	bool noRepeats = false;


	numberOfTask = _storage.getSameDateCount(date);

	while (noRepeats == false) {
		// if task is unbounded, i.e. no date
		if (date == "unbounded event") {
			if (numberOfTask < 10) {
				returnIndex = defaultIndex + "0" + to_string(numberOfTask);
			}
			else {
				returnIndex = defaultIndex + to_string(numberOfTask);
			}
		}
		else { // a date exists and should be in standard form i.e. 3/3

			int pos = date.find('/');
			string temp = "";

			// assert pos
			if (pos > 0) {
				// extract day
				temp = date.substr(0, pos);
				if (temp.size() == 1) {
					returnIndex = "0";
				}
				returnIndex = returnIndex + temp;

				// extract month
				temp = date.substr(pos + 1);
				if (temp.size() == 1) {
					returnIndex = returnIndex + "0";
				}
				returnIndex = returnIndex + temp;

				// add in counter
				if (numberOfTask < 10) {
					returnIndex = returnIndex + "0" + to_string(numberOfTask);
				}
				else {
					returnIndex = returnIndex + to_string(numberOfTask);
				}
			}
		}
		noRepeats = _storage.noRepeatIndexCount(returnIndex);

		if (noRepeats == false) {
			numberOfTask++;
			returnIndex == "";
		}
	} // end noRepeat while loop

	return returnIndex;

}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\HandleInput.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Logic.cpp
	 */

Executor* Logic::dispatch(UserTask* task) {

	switch (task->getCommand()) {
	case ADD:
		return new ExecuteAdd(task);
	case DELETE:
		return new ExecuteDelete(task);
	case EDIT:
		return new ExecuteEdit(task);
	case SEARCH:
		return new ExecuteSearch(task);
	case SORT:
		return new ExecuteSort(task);
	case DISPLAY:
		return new ExecuteDisplay(task);
	case HELP:
		return new ExecuteHelp(task);
	case MARK:
		return new ExecuteMark(task);
	case DIRECTORY:
		return new ExecuteDirectory(task);
	};
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Logic.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Standardise.cpp
	 */

string Standardise::standardiseTime(string inputTime) {

	if (inputTime.empty()) { // for no time input by user
		return "All day event";
	}

	if (inputTime == "All day event") {
		return inputTime;
	}

	if (inputTime == "99:99") {
		return "All day event";
	}

	int hour_s;
	int hour_e = 00;
	int min_s = 00;
	int min_e = 00;
	string AmPm;
	string changed;
	string shour_s;
	string shour_e;
	string smin_s;
	string smin_e;

	std::string::size_type sz;

	hour_s = stoi(inputTime, &sz);
	inputTime = inputTime.substr(sz);
	if (inputTime[0] == '.' || inputTime[0] == ':') { // there exists some minutes
		inputTime = inputTime.substr(1);
		min_s = stoi(inputTime, &sz);
		inputTime = inputTime.substr(sz);
	}

	// check for any am / pm attached to start time
	if (inputTime.find("am") == 0) {
		int midnight = 12;
		inputTime = inputTime.substr(2); // remove am
		if (hour_s == midnight) {
			hour_s = 0; // midnight = 00:00
		}
	}
	else if (inputTime.find("pm") == 0) {
		int numberOfHours = 12;
		inputTime = inputTime.substr(2); // remove pm
		if (hour_s < 12) {
			hour_s = hour_s + numberOfHours;
		}
	}

	if (inputTime[0] == '-') { // end time exists
		inputTime = inputTime.substr(1);
		hour_e = stoi(inputTime, &sz);
		inputTime = inputTime.substr(sz);
		if (inputTime[0] == '.' || inputTime[0] == ':') { // there exists some minutes
			inputTime = inputTime.substr(1);
			min_e = stoi(inputTime, &sz);
			inputTime = inputTime.substr(sz);
		}

		// check for any am / pm attached to end time
		if (inputTime.find("am") == 0) {
			int midnight = 12;
			inputTime = inputTime.substr(2); // remove am
			if (hour_e == midnight) {
				hour_e = 0; // midnight = 00:00
			}
		}
		else if (inputTime.find("pm") == 0) {
			int numberOfHours = 12;
			inputTime = inputTime.substr(2); // remove pm
			if (hour_e < 12) {
				hour_e = hour_e + numberOfHours;
			}
		}
	}
	else { // no end time found
		hour_e = hour_s + 1; // create an hour long event
		min_e = min_s;
	}


	// below just makes the 0's appear nicer. in output e.g. 00:00 rather than 0:0
	if (hour_s == 0) {
		shour_s = "00";
	}
	else {
		shour_s = to_string(hour_s);
	}

	if (hour_e == 0) {
		shour_e = "00";
	}
	else {
		shour_e = to_string(hour_e);
	}

	if (min_s == 0) {
		smin_s = "00";
	}
	else {
		smin_s = to_string(min_s);
	}

	if (min_e == 0) {
		smin_e = "00";
	}
	else {
		smin_e = to_string(min_e);
	}

	changed = shour_s + ":" + smin_s + "-" + shour_e + ":" + smin_e;

	return changed;

}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Standardise.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\StickyNote.cpp
	 */

void StickyNote::setDate(string change) {
	_date = change;

}

void StickyNote::setTime(string change) {
	_time = change;

}

void StickyNote::setPriority(string change) {
	_priority = change;

}

void StickyNote::setCategory(string change) {
	_category = change;
}

void StickyNote::setIndex(string change) {
	_index = change;
}

void StickyNote::setStatus(string change) {
	_status = change;
}

	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\StickyNote.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Storage.cpp
	 */

int Storage::getSameDateCount(string date) {

	list<StickyNote>::iterator iter;
	iter = _noteBook.begin();
	int size = _noteBook.size();
	int i = 0;
	int count = 0;
	for (iter; i < size; i++, iter++) {
		if (iter->getDate() == date) {
			count++;
		}
	}
	return count;
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Storage.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Storage.cpp
	 */

void Storage::findClashes(StickyNote& note) {

	int _size = getSize();
	list<StickyNote>::iterator iter;
	iter = getIter();

	for (int i = 0; i < _size; i++, iter++) {
		if ((note.getDate() == iter->getDate()) && iter->getStartTime() != 0 && 
				iter->getEndTime() != 0 && iter->getStatus() != "cleared") {

					if (!(note.getStartTime() > iter->getStartTime() && note.getStartTime() >= iter->getEndTime())
						&& !(note.getEndTime() <= iter->getStartTime() && note.getEndTime() < iter->getEndTime())) {
							note.setStatus("Clash");
						iter->setStatus("Clash");
					}
			}
	}
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\Storage.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\UserTask.cpp
	 */

COMMAND UserTask::getCommand() {
	return _command;

}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\oop test\UserTask.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\UnitTest\unittest1.cpp
	 */

//Unit test for ADD.

			TEST_METHOD(ADDvalid)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add meet zann today 8pm -high\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(true, successful);
			}

			TEST_METHOD(ADDinvaliddate1)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add meet zann 43/5 -high\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(false, successful);
			}

			TEST_METHOD(ADDinvaliddate2)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add meet zann may 43 -high\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(false, successful);
			}

			TEST_METHOD(ADDinvaliddate3)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add meet zann 43 may -high\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(false, successful);
			}

			TEST_METHOD(ADDexceptiondate)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add meet zann 99/99 -high\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(true, successful);
			}

//Unit test for ADD.
			TEST_METHOD(ADDinvalidtime)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add meet zann 25:00 -high\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(false, successful);
			}

			TEST_METHOD(ADDinvalidtime2)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add meet zann 25:00-23:00 -high\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(false, successful);
			}

			TEST_METHOD(ADDinvalidtime3)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add meet zann 6pm-5pm -high\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(false, successful);
			}

			TEST_METHOD(ADDnoinfo)
			{
				bool edited = false;
				bool successful = false;
				Logic* logic = new Logic;
				string input = "add\r\n";
				logic->handleInput(input, edited, successful);
				Assert::AreEqual(false, successful);
			}

	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\UnitTest\unittest1.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\WiseUI\CurrentDate.cpp
	 */

string CurrentDate::getCurrentDate(){
	time_t rawTime;
	struct tm * timeInfo = new struct tm;

	time(&rawTime);
	localtime_s(timeInfo, &rawTime);

	int day = timeInfo->tm_mday;
	int month = timeInfo->tm_mon + 1;
	int year = timeInfo->tm_year + 1900;

	ostringstream oss;
	oss << day << "/" << month << "/" << year;
	return oss.str();
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\WiseUI\CurrentDate.cpp





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\WiseUI\WiseGUI.h
	 */

		WiseGUI(void)
		{
			logic = new Logic;
			_log = new Log;
			InitializeComponent();
			String^ dateDisplayed = gcnew String(date.c_str());
			dateBox->Text = dateDisplayed;

			bool successful = false;
			bool edited = false;
			string temp = logic->handleInput("display", edited, successful);
			String^ tasksToBeDisplayed = gcnew String(temp.c_str());
			displayBox->Text = tasksToBeDisplayed;
		}

	protected:
		~WiseGUI()
		{
			if (components)
			{
				delete components;
			}
		}

	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\WiseUI\WiseGUI.h





	/**
	 * origin: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\WiseUI\WiseGUI.h
	 */

	private: System::Void CmdLineBox_TextChanged(System::Object^  sender, System::EventArgs^  e) {
				 String^ newCmd = CmdLineBox->Text;
				 int size = newCmd->Length;
				 if (size == 0){
				 }
				 else{
					 char lastElement = newCmd[size - 1];
					 if (lastElement == '\n'){
						 Enter_Click(sender, e);
						 CmdLineBox->Clear();
					 }
				 }
	} 
	private: System::Void Enter_Click(System::Object^  sender, System::EventArgs^  e) {
				 bool edited = false;

				 if (CmdLineBox->Text == "\r\n"){
					 MessageBox::Show("Wrong Input, re-enter:");
				 }
				 else{

					 string input = msclr::interop::marshal_as<std::string>(CmdLineBox->Text);
					 _log->logInfo(input);

					 if (input[input.length() - 1] == '\r' && input[input.length()] == '\n') {
						 input = input.substr(0, input.length() - 2);
					 }

					 bool successful = false;
					 string result = logic->handleInput(input, edited, successful);
					 ostringstream message;
					 message << SUCCESSFUL_LOG << endl;
					 _log->logInfo(message.str());

					 String^ feedback = gcnew String(result.c_str());


					 for (size_t i = 0; i < input.size(); i++){
						 input[i] = tolower(input[i]);
					 }

					 istringstream iss(input);
					 string cmd = "";

					 if (input.size() > 0){
						 iss >> cmd;
					 }

					 if (cmd == "help") {
						 MessageBox::Show(feedback);
					 }
					 else if (cmd == "display" && result != MESSAGE_ERROR) {
						 dateBox->Text = gcnew String(date.c_str());
						 displayBox2->Clear();
						 if (input == "display week\r\n") {
							 string toShow = date + " to " + date7daysLater;
							 dateBox->Text = gcnew String(toShow.c_str());
						 }
						 displayBox->Text = feedback;
					 }
					 else {
						 displayBox2->Text = feedback;
					 }

					 if (edited){
						 dateBox->Text = gcnew String(date.c_str());
						 string temp;
						 bool successful = false;
						 if (cmd == "search") {
							 temp = logic->handleInput("display search", edited, successful);
						 }
						 else {
							 temp = logic->handleInput("display", edited, successful);
						 }
						 String^ tasksToBeDisplayed = gcnew String(temp.c_str());
						 displayBox->Text = tasksToBeDisplayed;
					 }
				 }
				
				 return;
	}

	private: System::Void WiseManager_MouseDoubleClick(System::Object^  sender, System::Windows::Forms::MouseEventArgs^  e) {
			 this->Show();
	}
	private: System::Void showWindowToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e) {
			 this->Show(); 
	}
	private: System::Void hideWindowToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e) {
			 this->Hide();
	}
	private: System::Void exitToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e) {
				 bool successful = false;
				 bool edited = false;
				 logic->handleInput("exit\r\n", edited, successful);
				 this->Close();
	}

	private: System::Void WiseGUI_KeyDown(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
			 if ((e->KeyCode == System::Windows::Forms::Keys::F1)){
				 this->Hide();
				 WiseManager->ShowBalloonTip(1000, "Dear user:", "WiseManager now is running in system tray.", ToolTipIcon::None);
			 }
			 else if ((e->KeyCode == System::Windows::Forms::Keys::Escape)){
				 bool successful = false;
				 bool edited = false;
				 logic->handleInput("exit\r\n", edited, successful);
				 this->Close();
			 }
			 else{
			 }
			 return;
	}
private: System::Void WiseGUI_FormClosing(System::Object^  sender, System::Windows::Forms::FormClosingEventArgs^  e) {
			 bool successful = false;
			 bool edited = false;
			 logic->handleInput("exit\r\n", edited, successful);
			 this->Close();
}
};
}
	// End of segment: D:\NUS\Year 2 Sem 2 AY 14-15\CS2103\Wisemanager\V0.4\WiseUI\WiseGUI.h





